package org.javando.http.problem;

import org.slf4j.Logger
import org.slf4j.LoggerFactory

import java.net.URI
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.*

val log: Logger = LoggerFactory.getLogger(Problem::class.java)

interface ProblemKt {

    /**
     *  A human-readable explanation specific to this occurrence of the problem.
     *
     *  The "detail" member, if present, ought to focus on helping the client
     *  correct the problem, rather than giving debugging information.
     *
     *  Consumers SHOULD NOT parse the "detail" member for information;
     *  extensions are more suitable and less error-prone ways to obtain such
     *  information.
     *
     *  source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    val details: String?

    /**
     *  A short, human-readable summary of the problem
     *  type.  It SHOULD NOT change from occurrence to occurrence of the
     *  problem, except for purposes of localization (e.g., using
     *  proactive content negotiation)
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    val title: String

    /**
     *
     * The HTTP status code ([RFC7231, Section 6](https://tools.ietf.org/html/rfc7231#section-6))
     * generated by the origin server for this occurrence of the problem.
     *
     * The "status" member, if present, is only advisory; it conveys the
     * HTTP status code used for the convenience of the consumer.
     * Generators MUST use the same status code in the actual HTTP response,
     * to assure that generic HTTP software that does not understand this
     * format still behaves correctly.
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    val status: HttpStatus

    /**
     *
     * A URI reference ([RFC3986](https://tools.ietf.org/html/rfc3986))
     * that identifies the
     * problem type.  This specification encourages that, when
     * dereferenced, it provide human-readable documentation for the
     * problem type (e.g., using [W3C HTML5](https://tools.ietf.org/html/rfc7807#ref-W3C.REC-html5-20141028)).  When
     * this member is not present, its value is assumed to be
     * "about:blank".
     *
     * Note that both "type" and "instance" accept relative URIs
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    var type: URI


    /**
     *
     * A URI reference ([RFC3986](https://tools.ietf.org/html/rfc3986))
     * that identifies  the specific
     * occurrence of the problem.  It may or may not yield further
     * information if dereferenced.
     *
     * Note that both "type" and "instance" accept relative URIs
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    val instance: URI?


    /**
     *
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "balance" and "accounts" to convey additional, problem-
     * specific information.
     *
     * Clients consuming problem details must ignore any such extensions
     * that they don't recognize; this allows problem types to evolve and
     * include additional information in the future.
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    val extensions: Map<String, JsonValue>

    /**
    * Serialize the problem in a JSON Object that conforms to the [RFC 7807][https://tools.ietf.org/html/rfc7807] specification.
    *
    * @return The serialized problem in a JSON Object string
    */
    fun toJson(): String

    /**
     * Serialize this problem into a provider-independent JSON Object.
     *
     * See [JsonObject] for more information on how to extract json properties from this object
     * @return The new [JsonObject] instance
     */
    fun toJsonObject(): JsonObject

    /**
     * Extracts, if present, an extension value with the given name and of the specified type.
     *
     * @param name The name of the property as it is in the JSON string
     * @param klass The type in which the property will be deserialized.
     * @return The requested property or null if the property cannot be found or if it cannot be deserialized into the specified class.
     */
    fun <T> getExtensionValue(name: String, klass: Class<T>): T?

    /**
     * Extracts, if present, an extension value of the specified type.
     *
     * The name of the property will be inferred by the class name, converting
     * the PascalCase of the class name into the typical 'snake_case' of JSON properties.
     *
     * ```
     *
     * // suppose you have this custom class...
     * data class CreditInfo(val balance: Double, val currency: String = "EUR")
     *
     * // The inferred property name will be 'credit_info'
     * var creditInfo = provider.registerExtensionClass(CreditInfo::class.java)
     *
     *```
     *
     * **Note that if the class name does not follow the standard naming conventions, this method won't work.**
     * @param klass The type in which the property will be deserialized.
     * @return The requested property or null if the property cannot be found or if it cannot be deserialized into the specified class.
     */
    fun <T> getExtensionValue(klass: Class<T>): T?
}

abstract class ProblemBuilder(protected val jsonProvider: JsonProvider) {

    protected var details: String? = null
    protected var title: String? = null
    protected var status: HttpStatus? = null
    protected var instance: URI? = null
    protected var type: URI = URI("about:blank")

    private val reservedKeywords = listOf("title", "details", "status", "instance", "type", "stacktrace", "exceptions")

    @Transient
    protected val extensions = mutableMapOf<String, JsonValue>()


    /**
     *  A short, human-readable summary of the problem
     *  type.
     *
     *  It SHOULD NOT change from occurrence to occurrence of the
     *  problem, except for purposes of localization (e.g., using
     *  proactive content negotiation)
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    protected open fun title(title: String): ProblemBuilder {
        this.title = title
        return this
    }

    /**
     *  A human-readable explanation specific to this occurrence of the problem.
     *
     *  The "detail" member, if present, ought to focus on helping the client
     *  correct the problem, rather than giving debugging information.
     *
     *  Consumers SHOULD NOT parse the "detail" member for information;
     *  extensions are more suitable and less error-prone ways to obtain such
     *  information.
     *
     *  source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    protected open fun details(details: String): ProblemBuilder {
        this.details = details
        return this
    }

    /**
     *
     * A URI reference ([RFC3986](https://tools.ietf.org/html/rfc3986))
     * that identifies the
     * problem type.  This specification encourages that, when
     * dereferenced, it provide human-readable documentation for the
     * problem type (e.g., using [W3C HTML5](https://tools.ietf.org/html/rfc7807#ref-W3C.REC-html5-20141028)).  When
     * this member is not present, its value is assumed to be
     * "about:blank".
     *
     * Note that both "type" and "instance" accept relative URIs
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    protected open fun type(uri: URI): ProblemBuilder {
        this.type = uri
        return this
    }

    /**
     *
     * The HTTP status code ([RFC7231, Section 6](https://tools.ietf.org/html/rfc7231#section-6))
     * generated by the origin server for this occurrence of the problem.
     *
     * The "status" member, if present, is only advisory; it conveys the
     * HTTP status code used for the convenience of the consumer.
     * Generators MUST use the same status code in the actual HTTP response,
     * to assure that generic HTTP software that does not understand this
     * format still behaves correctly.
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    protected open fun status(status: HttpStatus): ProblemBuilder {
        this.status = status
        return this
    }

    /**
     *
     * A URI reference ([RFC3986](https://tools.ietf.org/html/rfc3986))
     * that identifies  the specific
     * occurrence of the problem.  It may or may not yield further
     * information if dereferenced.
     *
     * Note that both "type" and "instance" accept relative URIs
     *
     * source: [RFC 7807](https://tools.ietf.org/html/rfc7807#page-5)
     */
    protected open fun instance(uri: URI): ProblemBuilder {
        this.instance = uri
        return this
    }

    open fun addExtensions(vararg pairs: Pair<String, JsonValue>): ProblemBuilder {
        return addExtensions(pairs.toList())
    }

    open fun addExtensions(pairs: List<Pair<String, JsonValue>>): ProblemBuilder {
        val mutable = pairs.toMutableList()

        mutable.removeIf {
            if (it.first in reservedKeywords)
                log.warn("Found custom '${it.first}' extension: It is a reserved keyword and will not be added.")
            it.first in reservedKeywords
        }

        mutable.forEach { addExtensionInternal(it.first, it.second) }
        return this
    }

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", Date())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: String) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", Date())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: Int) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_amount" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_amount", 13.55f)
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: Float) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", Date())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: Boolean) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_amount" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_amount", 88.21)
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: Double) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", Date())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: Date) = addExtensionInternal(name, jsonProvider.newValue(value))

    /**
     * The Problem object can be extended with additional members.
     * When adding date values, the provider's [JsonProvider.defaultDatePattern] date format will be used .
     *
     * You can change it with [JsonProvider.setDateFormat] method.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", ZonedDateTime.now())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     *
     */
    open fun addExtension(name: String, value: ZonedDateTime) = addExtension(name, Date.from(value.toInstant()))

    /**
     * The Problem object can be extended with additional members.
     * When adding date values, the provider's [JsonProvider.defaultDatePattern] date format will be used .
     *
     * You can change it with [JsonProvider.setDateFormat] method.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", LocalDateTime.now())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value The associated value
     */
    open fun addExtension(name: String, value: LocalDateTime) = addExtension(name, value.atZone(ZoneId.systemDefault()))

    /**
     * The Problem object can be extended with additional members.
     *
     * For example, an "out of credit" problem can define two
     * extensions -- "account_number" and "transaction_date" to convey additional, problem-
     * specific information.
     *
     * For example:
     * ```
     * val p = Problem.wither(provider)
     *   .withTitle("Insufficient Credit")
     *   .withDetails("There's no sufficient credit in the account for the requested transaction")
     *   ...
     *   .addExtension("account_number", 7699123)
     *   .addExtension("transaction_date", Date())
     *   .build()
     * ```
     *
     * @param name The name of the extension member (i.e the new json property)
     * @param value A custom class to be serialized as JsonObject or JsonArray (if it is a collection).
     */
    open fun addExtension(name: String, value: Any) = addExtensionInternal(name, jsonProvider.newValue(value))



    /**
     *  Although it is not advisable to add the stacktrace of an exception as a member extensions, it
     *  can be helpful when debugging a system. It should be avoided in production since exception messages
     *  and stacktraces ***contains information on the implementation's internals and therefore can expose
     *  your system to security threats***.
     *
     *  As stated in the [RFC 7807](https://tools.ietf.org/html/rfc7807#page-8) document:
     *
     *  > "When defining a new problem type, the information included must be
     *  > carefully vetted.  Likewise, when actually generating a problem --
     *  > however it is serialized -- the details given must also be
     *  > scrutinized.
     *
     *  > Risks include leaking information that can be exploited to
     *  > compromise the system, access to the system, or the privacy of
     *  > users of the system."
     *
     * ***Use at your own risk.***
     *
     *  ``` kotlin
     *
     *  val problemClassic = Problem.create(provider)
     *  .title("Authorization Error")
     *  ... // other builder calls...
     *  .addExtension(exception) // 'exception' can be any exception type.
     *  .build()
     *
     *  ```
     *
     *  @param exception The exception to include as an extension member. Only the class name and the exception message will be serialized.
     */
    open fun addExtension(exception: Throwable) = addExtensionInternal("exceptions", jsonProvider.newValue(exception))

    /**
     *  Although it is not advisable to add the stacktrace of an exception as a member extensions, it
     *  can be helpful when debugging a system. It should be avoided in production since exception messages
     *  and stacktraces ***contains information on the implementation's internals and therefore can expose
     *  your system to security threats***.
     *
     *  As stated in the [RFC 7807](https://tools.ietf.org/html/rfc7807#page-8) document:
     *
     *  > "When defining a new problem type, the information included must be
     *  > carefully vetted.  Likewise, when actually generating a problem --
     *  > however it is serialized -- the details given must also be
     *  > scrutinized.
     *
     *  > Risks include leaking information that can be exploited to
     *  > compromise the system, access to the system, or the privacy of
     *  > users of the system."
     *
     * ***Use at your own risk.***
     *
     *  ``` kotlin
     *
     *  val problemClassic = Problem.create(provider)
     *  .title("Authorization Error")
     *  ... // other builder calls...
     *  .addExtension(exception.stackTrace, depth = 3, excludePackages = arrayOf("*junit*", "java.lang.*"))
     *  .build()
     *
     *  ```
     *  In the code example we have limited the stacktrace depth to only 3 elements and we have also excluded the packages that contains `junit` or starts with `java.lang.`
     *  The `*` can be used as an ant matcher.
     * @param stacktrace The array of [StackTraceElement] that is provided with every exception.
     * @param depth (Optional) The maximum elements to extract from the array, starting from the topmost.
     * @param excludePackages (Optional) The packages to be excluded from the serialized stacktrace elements.
     * You can use the universal selector ' * ' to specify any character
     * (for ex. java.lang.* will exclude all classes of the java.lang package)
     */
    @JvmOverloads
    open fun addExtension(stacktrace: Array<StackTraceElement>, depth: Int = 10, vararg excludePackages: String = arrayOf()): ProblemBuilder {
        val ps = Properties()
        ps[JsonValue.stacktracePropertyKeyDepth] = if(depth < 0) 1 else depth
        ps[JsonValue.stacktracePropertyKeyExcludedPackages] = excludePackages.toMutableList().apply { addAll(listOf("jdk.*", "java.lang.reflect.*")) }
        return addExtensionInternal("stacktrace",
            jsonProvider.newValue(stacktrace, ps).apply { properties.putAll(ps) }
        )
    }

    internal fun addExtensionInternal(name: String, value: JsonValue): ProblemBuilder {
        extensions[name] = value
        return this
    }

    internal fun addExtensionsInternal(pairs: List<Pair<String, JsonValue>>): ProblemBuilder {
        pairs.forEach { addExtensionInternal(it.first, it.second) }
        return this
    }

    /**
     * @return the newly created Problem instance.
     * @throws ProblemBuilderException If all the required fields has not been filled or if any other error occur.
     */
    abstract fun build(): Problem

    override fun toString() =
        "ProblemBuilder(jsonProvider=$jsonProvider, details=$details, title=$title, status=$status, instance=$instance, type=$type, extensions=$extensions)"
}